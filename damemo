#!/usr/bin/env ruby

# usage:
#   memo                # new entry
#   memo keywords...    # search keywords

# memo-file format
#
# = :keyword1:keyword2:...: title for 1st entry
# content
# [YYYY-MM-DD HH:MM:SS]-[YYYY-MM-DD HH:MM:SS]
#
# = title for 2nd entry
# ...
#

require 'tmpdir'
require 'fileutils'
require 'optparse'
require 'time'
require 'pp'

$memo_file = "#{ENV['HOME']}/.damemo/memo.txt"
$editor = ENV['VISUAL'] || ENV['EDITOR'] || 'vi'

def shell_quote(str)
  str.gsub(/'|[^']+/) {|s|
    s == "'" ? "\\'" : "'#{s}'"
  }
end

def cvs_maintained?(filename)
  dir, name = File.split(filename)
  File.directory?("#{dir}/CVS") &&
  %r{^/#{Regexp.quote name}/} =~ File.read("#{dir}/CVS/Entries")
end

def update_file(filename)
  if cvs_maintained?(filename)
    dir, name = File.split(filename)
    system("cd #{shell_quote dir}; cvs -Q update #{shell_quote name}")
  end
end

def commit_file(filename)
  if cvs_maintained?(filename)
    dir, name = File.split(filename)
    system("cd #{shell_quote dir}; cvs commit -mupdate #{shell_quote name}")
  end
end

def modify_file(filename)
  update_file(filename)
  old_content = open(filename, File::CREAT|File::RDWR) {|f|
    f.read
  }
  new_content = yield old_content.dup
  return if old_content == new_content
  new = filename + '.new'
  File.open(new, 'w') {|f| f << new_content }
  bak = filename + '.bak'
  File.unlink(bak) if File.exist? bak
  File.link(filename, bak)
  File.rename(new, filename)
  commit_file(filename)
end

def run_editor(content)
  tmpdir = "#{Dir.tmpdir}/memo-#$$"
  Dir.mkdir tmpdir, 0700
  begin
    filename = "#{tmpdir}/memo.txt"
    File.open(filename, 'w') {|f| f << content }
    system($editor, filename)
    File.read(filename)
  ensure
    FileUtils.rm_rf tmpdir
  end
end

DATEPAT = /\d{4}-\d\d-\d\d \d\d:\d\d:\d\d/
DATEFMT = '%Y-%m-%d %T'

# yields each memo entry as a string.
#
# memo-file format:
#
#   = :keyword1:keyword2:...: title for 1st entry
#   content
#   [YYYY-MM-DD HH:MM:SS]-[YYYY-MM-DD HH:MM:SS]
#  
#   = title for 2nd entry
#   ...
#
def scan_memo1(content)
  beg = nil
  content.scan(/^= |\z/) {
    m = $~
    if !beg
      beg = m.begin(0)
      next
    end
    entry = content[beg...m.begin(0)]
    entry.sub!(/\s*\z/, '')
    if /\n\[#{DATEPAT}\]-\[#{DATEPAT}\]\s*(?:id:(\d+))?\z/o !~ entry # xxx: year 10000 problem
      unless entry.sub!(/^\[(#{DATEPAT})\].*\z/) { "[#{$1}]-[#{$1}]" } # comversion from old damemo.
        entry << "\n" if /\n\z/ !~ entry
        entry << Time.now.strftime("[#{DATEFMT}]-[#{DATEFMT}]")
      end
    end
    entry << "\n\n"
    yield entry
    beg = m.begin(0)
  }
end

def scan_memo(content)
  if block_given?
    scan_memo1(content) {|str| yield str }
  else
    result = []
    scan_memo1(content) {|str| result << str }
    result
  end
end

class Entry
  def Entry.parse(entry)
    if /\A=( +:(?:[^:]+:)+)? +(.*)\n((?:.*\n)*)\[(#{DATEPAT})\]-\[(#{DATEPAT})\]\s*(?:id:(\d+))?\s*/o !~ entry
      raise ArgumentError, "unexpected format: #{entry.inspect}"
    end
    keywords = $1
    title = $2
    content = $3
    create_time = $4
    last_time = $5
    id = $6
    if keywords
      keywords.sub!(/^ +:/, '')
      keywords = keywords.split(/:/)
    else
      keywords = []
    end
    id = id.to_i if id
    Entry.new(keywords, title, content, create_time, last_time, id)
  end

  def initialize(keywords, title, content, create_time, last_time, id=nil)
    @keywords = keywords
    @title = title
    @content = content
    @create_time = create_time
    @last_time = last_time
    @id = id
  end
  attr_reader :keywords, :title, :content, :create_time
  attr_accessor :last_time, :id

  def ==(other)
    @keywords == other.keywords &&
    @title == other.title &&
    @content == other.content &&
    @create_time == other.create_time &&
    @last_time == other.last_time &&
    @id == other.id
  end

  def compose
    if @keywords.empty?
      keywords = ""
    else
      keywords = " :#{@keywords.join(':')}:"
    end
    if /\n\z|\A\z/ =~ @content
      content = @content
    else
      content = "#{@content}\n"
    end
    if @id
      id = " id:#{@id}"
    else
      id = ''
    end
    "=#{keywords} #{@title}\n#{content}[#{@create_time}]-[#{@last_time}]#{id}\n\n"
  end
end

def reorder_memo(ents, keywords)
  if keywords.empty?
    ents.sort_by {|e| e.last_time }.reverse
  else
    rest_keywords = keywords.dup
    kw = rest_keywords.shift
    pat = /#{Regexp.quote kw}/i
    match, rest = ents.partition {|e| pat =~ e.compose }
    has_kw, match = match.partition {|e| e.keywords.include? kw }
    result = []
    result.concat reorder_memo(has_kw, rest_keywords)
    result.concat reorder_memo(match, rest_keywords)
    result.concat reorder_memo(rest, rest_keywords)
    result
  end
end

def reset_id(ents)
  h = {}
  id = 0
  ents.each {|e|
    e.id = nil
    k = [e.create_time, e.last_time]
    if h.include? k
      e.id = id
      id += 1
    end
    h[k] = true
  }
end

def clear_id(ents)
  ents.each {|e|
    e.id = nil
  }
end

def update_memo(original_ents, modified_ents, now)
  h = {}
  original_ents.each_with_index {|e, i|
    k = [e.create_time, e.last_time, e.id]
    h[k] = i
  }
  result = Array.new(original_ents.length)
  modified_ents.each {|e|
    k = [e.create_time, e.last_time, e.id]
    if h[k]
      if e != original_ents[h[k]]
        e.last_time = now
      end
      result[h[k]] = e
      h.delete k
    else
      e.last_time = now
      result << e
    end
  }
  result.compact!
  result
end

def search_last_keywords(ents)
  last_modified = nil
  keywords = []
  ents.each {|e|
    if !last_modified
      keywords = e.keywords
      last_modified = e.last_time
    elsif last_modified < e.last_time
      keywords = e.keywords
      last_modified = e.last_time
    end
  }
  keywords
end

def memo(keywords)
  modify_file($memo_file) {|content|
    ents = scan_memo(content).map {|str| str }
    ents = ents.map {|str| Entry.parse(str) }
    if keywords.empty?
      keywords = search_last_keywords(ents)
    end
    reset_id(ents)
    ents2 = reorder_memo(ents, keywords)
    now = Time.now.strftime(DATEFMT)
    new_entry = Entry.new(keywords, '', '', now, now)
    ents2.unshift new_entry
    content2 = ents2.map {|e| e.compose }.join
    content3 = run_editor(content2)
    return if content3 == content2
    ents3 = scan_memo(content3).map {|str| Entry.parse(str) }
    ents3.shift if !ents3.empty? && ents3[0] == new_entry
    ents4 = update_memo(ents, ents3, now)
    clear_id(ents4)
    ents4.map {|e| e.compose }.join
  }
end

def main
  action = :memo
  ARGV.options {|q|
    q.def_option('--help') { puts q; exit(0) }
    q.def_option('--list-keywords') { action = :list_keywords }
    q.parse!
  }
  case action
  when :memo
    memo(ARGV)
  when :list_keywords
  else
    raise "[bug] unexpected action"
  end
end

main
